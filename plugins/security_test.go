package plugins

import (
	"fmt"
	"os"
	"path/filepath"
	"sync"
	"testing"
	"time"
)

// setupSecurityManagerWithKeys creates a SecurityManager and generates key pair for testing
func setupSecurityManagerWithKeys(t *testing.T) *SecurityManager {
	sm := NewSecurityManager()
	if err := sm.GenerateKeyPair(); err != nil {
		t.Fatalf("GenerateKeyPair failed: %v", err)
	}
	return sm
}

// TestNewSecurityManager tests creation of a new security manager
func TestNewSecurityManager(t *testing.T) {
	sm := NewSecurityManager()
	if sm == nil {
		t.Fatal("NewSecurityManager returned nil")
	}

	if sm.signatures == nil {
		t.Error("signatures map not initialized")
	}

	if sm.trustedKeys == nil {
		t.Error("trustedKeys map not initialized")
	}

	if sm.auditLog == nil {
		t.Error("auditLog not initialized")
	}
}

// TestGenerateKeyPair tests RSA key pair generation
func TestGenerateKeyPair(t *testing.T) {
	sm := NewSecurityManager()

	// GenerateKeyPair only returns error
	err := sm.GenerateKeyPair()
	if err != nil {
		t.Fatalf("GenerateKeyPair failed: %v", err)
	}

	// Verify keys were generated by checking internal state
	if sm.privateKey == nil {
		t.Error("private key is nil")
	}

	if sm.publicKey == nil {
		t.Error("public key is nil")
	}

	// Verify key size is 2048 bits
	if sm.privateKey.N.BitLen() != 2048 {
		t.Errorf("Expected 2048-bit key, got %d bits", sm.privateKey.N.BitLen())
	}
}

// TestSignPlugin tests plugin code signing
func TestSignPlugin(t *testing.T) {
	sm := NewSecurityManager()

	// Create temporary test file
	tmpDir := t.TempDir()
	testFile := filepath.Join(tmpDir, "test_plugin.go")
	testCode := []byte("package main\n\nfunc main() {}\n")
	if err := os.WriteFile(testFile, testCode, 0644); err != nil {
		t.Fatalf("Failed to create test file: %v", err)
	}

	// Generate key pair first - required for signing
	if err := sm.GenerateKeyPair(); err != nil {
		t.Fatalf("GenerateKeyPair failed: %v", err)
	}

	pluginID := "test_plugin_001"

	// Sign the plugin - SignPlugin takes (pluginID, codePath) and returns (*PluginSignature, error)
	sig, err := sm.SignPlugin(pluginID, testFile)
	if err != nil {
		t.Fatalf("SignPlugin failed: %v", err)
	}

	// Verify signature was created
	if sig == nil {
		t.Fatalf("SignPlugin returned nil signature")
	}

	if sig.Hash == "" {
		t.Error("Hash is empty")
	}

	if sig.Signature == "" {
		t.Error("Signature is empty")
	}

	if sig.SignedBy != "ff6editor-system" {
		t.Errorf("Expected SignedBy=ff6editor-system, got %s", sig.SignedBy)
	}

	if sig.Revoked {
		t.Error("New signature should not be revoked")
	}
}

// TestVerifyPlugin tests plugin signature verification
func TestVerifyPlugin(t *testing.T) {
	sm := setupSecurityManagerWithKeys(t)

	// Create temporary test file
	tmpDir := t.TempDir()
	testFile := filepath.Join(tmpDir, "test_plugin.go")
	testCode := []byte("package main\n\nfunc main() {}\n")
	if err := os.WriteFile(testFile, testCode, 0644); err != nil {
		t.Fatalf("Failed to create test file: %v", err)
	}

	pluginID := "test_plugin_002"

	// Sign the plugin
	sig, err := sm.SignPlugin(pluginID, testFile)
	if err != nil {
		t.Fatalf("SignPlugin failed: %v", err)
	}

	if sig == nil {
		t.Fatalf("SignPlugin returned nil")
	}

	// Verify the plugin
	verified, err := sm.VerifyPlugin(pluginID, testFile)
	if err != nil {
		t.Fatalf("VerifyPlugin failed: %v", err)
	}

	if !verified {
		t.Error("Plugin verification failed but should have succeeded")
	}
}

// TestVerifyPluginTamperedCode tests detection of tampered code
func TestVerifyPluginTamperedCode(t *testing.T) {
	sm := setupSecurityManagerWithKeys(t)

	// Create temporary test file
	tmpDir := t.TempDir()
	testFile := filepath.Join(tmpDir, "test_plugin.go")
	testCode := []byte("package main\n\nfunc main() {}\n")
	if err := os.WriteFile(testFile, testCode, 0644); err != nil {
		t.Fatalf("Failed to create test file: %v", err)
	}

	pluginID := "test_plugin_003"

	// Sign the plugin
	sig, err := sm.SignPlugin(pluginID, testFile)
	if err != nil {
		t.Fatalf("SignPlugin failed: %v", err)
	}

	if sig == nil {
		t.Fatalf("SignPlugin returned nil")
	}

	// Tamper with the code
	tamperedCode := []byte("package main\n\nfunc main() { println(\"hacked\") }\n")
	if err := os.WriteFile(testFile, tamperedCode, 0644); err != nil {
		t.Fatalf("Failed to tamper test file: %v", err)
	}

	// Verify should fail
	verified, err := sm.VerifyPlugin(pluginID, testFile)
	if err == nil && verified {
		t.Error("VerifyPlugin should have detected tampered code")
	}
}

// TestRevokeSignature tests signature revocation
func TestRevokeSignature(t *testing.T) {
	sm := setupSecurityManagerWithKeys(t)

	// Create and sign plugin
	tmpDir := t.TempDir()
	testFile := filepath.Join(tmpDir, "test_plugin.go")
	testCode := []byte("package main\n\nfunc main() {}\n")
	if err := os.WriteFile(testFile, testCode, 0644); err != nil {
		t.Fatalf("Failed to create test file: %v", err)
	}

	pluginID := "test_plugin_004"
	if sig, err := sm.SignPlugin(pluginID, testFile); err != nil || sig == nil {
		t.Fatalf("SignPlugin failed: %v", err)
	}

	// Revoke signature
	if err := sm.RevokeSignature(pluginID); err != nil {
		t.Fatalf("RevokeSignature failed: %v", err)
	}

	// Verify revoked signature - GetSignature returns just pointer
	sig := sm.GetSignature(pluginID)
	if sig == nil {
		t.Fatalf("GetSignature returned nil")
	}

	if !sig.Revoked {
		t.Error("Signature should be revoked")
	}

	// Verification should fail for revoked signature
	verified, _ := sm.VerifyPlugin(pluginID, testFile)
	if verified {
		t.Error("VerifyPlugin should fail for revoked signature")
	}
}

// TestTrustedKeys tests trusted key management
func TestTrustedKeys(t *testing.T) {
	sm := NewSecurityManager()

	keyID := "trusted_key_001"

	// Mock PEM-formatted public key (valid RSA PUBLIC KEY format)
	publicKeyPEM := `-----BEGIN RSA PUBLIC KEY-----
MIIBCgKCAQEA0Z3VS5JJcds3s9h0Z2WCDKp3QL+2hJP5D1qVlqBG6BBBhvRZnvX+
-----END RSA PUBLIC KEY-----`

	// Add trusted key - should succeed
	if err := sm.AddTrustedKey(keyID, publicKeyPEM); err != nil {
		t.Fatalf("AddTrustedKey failed: %v", err)
	}

	// Remove trusted key - should succeed
	if err := sm.RemoveTrustedKey(keyID); err != nil {
		t.Fatalf("RemoveTrustedKey failed: %v", err)
	}

	// Remove again should fail (key no longer exists)
	if err := sm.RemoveTrustedKey(keyID); err == nil {
		t.Error("RemoveTrustedKey should fail when key doesn't exist")
	}
}

// TestIsPluginTrusted tests plugin trust status
func TestIsPluginTrusted(t *testing.T) {
	sm := setupSecurityManagerWithKeys(t)

	// Create and sign plugin
	tmpDir := t.TempDir()
	testFile := filepath.Join(tmpDir, "test_plugin.go")
	testCode := []byte("package main\n\nfunc main() {}\n")
	if err := os.WriteFile(testFile, testCode, 0644); err != nil {
		t.Fatalf("Failed to create test file: %v", err)
	}

	pluginID := "test_plugin_005"
	if sig, err := sm.SignPlugin(pluginID, testFile); err != nil || sig == nil {
		t.Fatalf("SignPlugin failed: %v", err)
	}

	// Signed plugins with valid signatures are trusted
	if !sm.IsPluginTrusted(pluginID) {
		t.Error("Plugin should be trusted after signing")
	}

	// Get the signing key
	sig := sm.GetSignature(pluginID)
	if sig == nil {
		t.Fatalf("GetSignature returned nil")
	}

	// Add the signing certificate as trusted key using public API
	if err := sm.AddTrustedKey("test-key-"+pluginID, sig.Certificate); err != nil {
		t.Fatalf("AddTrustedKey failed: %v", err)
	}

	// Plugin should now be considered trusted
	if !sm.IsPluginTrusted(pluginID) {
		t.Error("Plugin should be trusted after adding key")
	}
}

// TestGetSignatures tests retrieving all signatures
func TestGetSignatures(t *testing.T) {
	sm := setupSecurityManagerWithKeys(t)

	// Create temporary directory
	tmpDir := t.TempDir()

	// Sign multiple plugins
	for i := 1; i <= 3; i++ {
		testFile := filepath.Join(tmpDir, fmt.Sprintf("test_plugin_%d.go", i))
		testCode := []byte("package main\n\nfunc main() {}\n")
		if err := os.WriteFile(testFile, testCode, 0644); err != nil {
			t.Fatalf("Failed to create test file: %v", err)
		}

		pluginID := "test_plugin_" + string(rune('0'+i))
		if _, err := sm.SignPlugin(pluginID, testFile); err != nil {
			t.Fatalf("SignPlugin failed: %v", err)
		}
	}

	// Get all signatures
	signatures := sm.GetSignatures()
	if len(signatures) != 3 {
		t.Errorf("Expected 3 signatures, got %d", len(signatures))
	}
}

// TestGetSecurityStats tests security statistics
func TestGetSecurityStats(t *testing.T) {
	sm := setupSecurityManagerWithKeys(t)

	// Create and sign plugins
	tmpDir := t.TempDir()
	testFile := filepath.Join(tmpDir, "test_plugin.go")
	testCode := []byte("package main\n\nfunc main() {}\n")
	if err := os.WriteFile(testFile, testCode, 0644); err != nil {
		t.Fatalf("Failed to create test file: %v", err)
	}

	// Sign two plugins
	if _, err := sm.SignPlugin("plugin1", testFile); err != nil {
		t.Fatalf("SignPlugin failed: %v", err)
	}
	if _, err := sm.SignPlugin("plugin2", testFile); err != nil {
		t.Fatalf("SignPlugin failed: %v", err)
	}

	// Revoke one
	if err := sm.RevokeSignature("plugin1"); err != nil {
		t.Fatalf("RevokeSignature failed: %v", err)
	}

	// Get stats
	stats := sm.GetSecurityStats()

	totalSigs, ok := stats["total_signatures"].(int)
	if !ok || totalSigs != 2 {
		t.Errorf("Expected total_signatures=2, got %v", stats["total_signatures"])
	}

	// Implementation uses "revoked_plugins" not "revoked_signatures"
	revokedSigs, ok := stats["revoked_plugins"].(int)
	if !ok || revokedSigs != 1 {
		t.Errorf("Expected revoked_plugins=1, got %v", stats["revoked_plugins"])
	}
}

// TestSignatureExpiry tests signature expiration
func TestSignatureExpiry(t *testing.T) {
	sm := setupSecurityManagerWithKeys(t)

	// Create test plugin
	tmpDir := t.TempDir()
	testFile := filepath.Join(tmpDir, "test_plugin.go")
	testCode := []byte("package main\n\nfunc main() {}\n")
	if err := os.WriteFile(testFile, testCode, 0644); err != nil {
		t.Fatalf("Failed to create test file: %v", err)
	}

	pluginID := "test_plugin_006"
	if _, err := sm.SignPlugin(pluginID, testFile); err != nil {
		t.Fatalf("SignPlugin failed: %v", err)
	}

	// Manually expire the signature - GetSignature returns just pointer
	sig := sm.GetSignature(pluginID)
	if sig == nil {
		t.Fatalf("GetSignature returned nil")
	}
	sig.ExpiresAt = time.Now().Add(-1 * time.Hour) // 1 hour ago

	// Verification should fail for expired signature
	verified, err := sm.VerifyPlugin(pluginID, testFile)
	if verified || err == nil {
		t.Error("VerifyPlugin should fail for expired signature")
	}
}

// TestConcurrentSigning tests concurrent signing operations
func TestConcurrentSigning(t *testing.T) {
	sm := setupSecurityManagerWithKeys(t)

	// Create test file
	tmpDir := t.TempDir()
	testFile := filepath.Join(tmpDir, "test_plugin.go")
	testCode := []byte("package main\n\nfunc main() {}\n")
	if err := os.WriteFile(testFile, testCode, 0644); err != nil {
		t.Fatalf("Failed to create test file: %v", err)
	}

	// Sign 10 plugins concurrently
	var wg sync.WaitGroup
	for i := 0; i < 10; i++ {
		wg.Add(1)
		go func(id int) {
			defer wg.Done()
			pluginID := "concurrent_plugin_" + string(rune('0'+id))
			if _, err := sm.SignPlugin(pluginID, testFile); err != nil {
				t.Errorf("Concurrent SignPlugin failed for %s: %v", pluginID, err)
			}
		}(i)
	}
	wg.Wait()

	// Verify all signatures created
	signatures := sm.GetSignatures()
	if len(signatures) != 10 {
		t.Errorf("Expected 10 concurrent signatures, got %d", len(signatures))
	}
}

// TestConcurrentVerification tests concurrent verification operations
func TestConcurrentVerification(t *testing.T) {
	sm := setupSecurityManagerWithKeys(t)

	// Create and sign test plugin
	tmpDir := t.TempDir()
	testFile := filepath.Join(tmpDir, "test_plugin.go")
	testCode := []byte("package main\n\nfunc main() {}\n")
	if err := os.WriteFile(testFile, testCode, 0644); err != nil {
		t.Fatalf("Failed to create test file: %v", err)
	}

	pluginID := "concurrent_verify"
	if _, err := sm.SignPlugin(pluginID, testFile); err != nil {
		t.Fatalf("SignPlugin failed: %v", err)
	}

	// Verify 10 times concurrently
	var wg sync.WaitGroup
	errors := make(chan error, 10)
	for i := 0; i < 10; i++ {
		wg.Add(1)
		go func() {
			defer wg.Done()
			if verified, err := sm.VerifyPlugin(pluginID, testFile); !verified || err != nil {
				errors <- err
			}
		}()
	}
	wg.Wait()
	close(errors)

	// Check for any errors
	for err := range errors {
		t.Errorf("Concurrent verification failed: %v", err)
	}
}

// TestAuditLog tests security audit logging
func TestAuditLog(t *testing.T) {
	sm := setupSecurityManagerWithKeys(t)

	// Create and sign plugin
	tmpDir := t.TempDir()
	testFile := filepath.Join(tmpDir, "test_plugin.go")
	testCode := []byte("package main\n\nfunc main() {}\n")
	if err := os.WriteFile(testFile, testCode, 0644); err != nil {
		t.Fatalf("Failed to create test file: %v", err)
	}

	pluginID := "audit_test_plugin"
	if _, err := sm.SignPlugin(pluginID, testFile); err != nil {
		t.Fatalf("SignPlugin failed: %v", err)
	}
	if _, err := sm.VerifyPlugin(pluginID, testFile); err != nil {
		t.Fatalf("VerifyPlugin failed: %v", err)
	}
	if err := sm.RevokeSignature(pluginID); err != nil {
		t.Fatalf("RevokeSignature failed: %v", err)
	}

	// Get audit log
	auditLog := sm.GetAuditLog()
	if len(auditLog) < 3 {
		t.Errorf("Expected at least 3 audit entries, got %d", len(auditLog))
	}

	// Verify audit entries contain expected event types
	eventTypes := make(map[string]bool)
	for _, entry := range auditLog {
		eventTypes[entry.EventType] = true
	}

	expectedEvents := []string{"sign", "verify", "revoke"}
	for _, event := range expectedEvents {
		if !eventTypes[event] {
			t.Errorf("Expected audit log to contain event type '%s'", event)
		}
	}
}
