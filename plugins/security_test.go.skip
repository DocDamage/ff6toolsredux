package plugins

import (
	"os"
	"path/filepath"
	"sync"
	"testing"
	"time"
)

// TestNewSecurityManager tests creation of a new security manager
func TestNewSecurityManager(t *testing.T) {
	sm := NewSecurityManager()
	if sm == nil {
		t.Fatal("NewSecurityManager returned nil")
	}
	
	if sm.signatures == nil {
		t.Error("signatures map not initialized")
	}
	
	if sm.trustedKeys == nil {
		t.Error("trustedKeys map not initialized")
	}
	
	if sm.auditLog == nil {
		t.Error("auditLog not initialized")
	}
}

// TestGenerateKeyPair tests RSA key pair generation
func TestGenerateKeyPair(t *testing.T) {
	sm := NewSecurityManager()
	
	// GenerateKeyPair only returns error
	err := sm.GenerateKeyPair()
	if err != nil {
		t.Fatalf("GenerateKeyPair failed: %v", err)
	}
	
	// Verify keys were generated by checking internal state
	if sm.privateKey == nil {
		t.Error("private key is nil")
	}
	
	if sm.publicKey == nil {
		t.Error("public key is nil")
	}
	
	// Verify key size is 2048 bits
	if sm.privateKey.N.BitLen() != 2048 {
		t.Errorf("Expected 2048-bit key, got %d bits", sm.privateKey.N.BitLen())
	}
}

// TestSignPlugin tests plugin code signing
func TestSignPlugin(t *testing.T) {
	sm := NewSecurityManager()
	
	// Create temporary test file
	tmpDir := t.TempDir()
	testFile := filepath.Join(tmpDir, "test_plugin.go")
	testCode := []byte("package main\n\nfunc main() {}\n")
	if err := os.WriteFile(testFile, testCode, 0644); err != nil {
		t.Fatalf("Failed to create test file: %v", err)
	}
	
	pluginID := "test_plugin_001"
	
	// Sign the plugin
	if err := sm.SignPlugin(pluginID, testFile, "TestSigner"); err != nil {
		t.Fatalf("SignPlugin failed: %v", err)
	}
	
	// Verify signature was created
	sig, err := sm.GetSignature(pluginID)
	if err != nil {
		t.Fatalf("GetSignature failed: %v", err)
	}
	
	if sig.Hash == "" {
		t.Error("Hash is empty")
	}
	
	if sig.Signature == "" {
		t.Error("Signature is empty")
	}
	
	if sig.SignedBy != "TestSigner" {
		t.Errorf("Expected SignedBy=TestSigner, got %s", sig.SignedBy)
	}
	
	if sig.Revoked {
		t.Error("New signature should not be revoked")
	}
}

// TestVerifyPlugin tests plugin signature verification
func TestVerifyPlugin(t *testing.T) {
	sm := NewSecurityManager()
	
	// Create temporary test file
	tmpDir := t.TempDir()
	testFile := filepath.Join(tmpDir, "test_plugin.go")
	testCode := []byte("package main\n\nfunc main() {}\n")
	if err := os.WriteFile(testFile, testCode, 0644); err != nil {
		t.Fatalf("Failed to create test file: %v", err)
	}
	
	pluginID := "test_plugin_002"
	
	// Sign the plugin
	if err := sm.SignPlugin(pluginID, testFile, "TestSigner"); err != nil {
		t.Fatalf("SignPlugin failed: %v", err)
	}
	
	// Verify the plugin
	verified, err := sm.VerifyPlugin(pluginID, testFile)
	if err != nil {
		t.Fatalf("VerifyPlugin failed: %v", err)
	}
	
	if !verified {
		t.Error("Plugin verification failed but should have succeeded")
	}
}

// TestVerifyPluginTamperedCode tests detection of tampered code
func TestVerifyPluginTamperedCode(t *testing.T) {
	sm := NewSecurityManager()
	
	// Create temporary test file
	tmpDir := t.TempDir()
	testFile := filepath.Join(tmpDir, "test_plugin.go")
	testCode := []byte("package main\n\nfunc main() {}\n")
	if err := os.WriteFile(testFile, testCode, 0644); err != nil {
		t.Fatalf("Failed to create test file: %v", err)
	}
	
	pluginID := "test_plugin_003"
	
	// Sign the plugin
	if err := sm.SignPlugin(pluginID, testFile, "TestSigner"); err != nil {
		t.Fatalf("SignPlugin failed: %v", err)
	}
	
	// Tamper with the code
	tamperedCode := []byte("package main\n\nfunc main() { println(\"hacked\") }\n")
	if err := os.WriteFile(testFile, tamperedCode, 0644); err != nil {
		t.Fatalf("Failed to tamper test file: %v", err)
	}
	
	// Verify should fail
	verified, err := sm.VerifyPlugin(pluginID, testFile)
	if err == nil && verified {
		t.Error("VerifyPlugin should have detected tampered code")
	}
}

// TestRevokeSignature tests signature revocation
func TestRevokeSignature(t *testing.T) {
	sm := NewSecurityManager()
	
	// Create and sign plugin
	tmpDir := t.TempDir()
	testFile := filepath.Join(tmpDir, "test_plugin.go")
	testCode := []byte("package main\n\nfunc main() {}\n")
	if err := os.WriteFile(testFile, testCode, 0644); err != nil {
		t.Fatalf("Failed to create test file: %v", err)
	}
	
	pluginID := "test_plugin_004"
	if err := sm.SignPlugin(pluginID, testFile, "TestSigner"); err != nil {
		t.Fatalf("SignPlugin failed: %v", err)
	}
	
	// Revoke signature
	if err := sm.RevokeSignature(pluginID, "Security issue"); err != nil {
		t.Fatalf("RevokeSignature failed: %v", err)
	}
	
	// Verify revoked signature
	sig, err := sm.GetSignature(pluginID)
	if err != nil {
		t.Fatalf("GetSignature failed: %v", err)
	}
	
	if !sig.Revoked {
		t.Error("Signature should be revoked")
	}
	
	// Verification should fail for revoked signature
	verified, _ := sm.VerifyPlugin(pluginID, testFile)
	if verified {
		t.Error("VerifyPlugin should fail for revoked signature")
	}
}

// TestTrustedKeys tests trusted key management
func TestTrustedKeys(t *testing.T) {
	sm := NewSecurityManager()
	
	keyID := "trusted_key_001"
	
	// Mock PEM-formatted public key (valid RSA PUBLIC KEY format)
	publicKeyPEM := `-----BEGIN RSA PUBLIC KEY-----
MIIBCgKCAQEA0Z3VS5JJcds3s9h0Z2WCDKp3QL+2hJP5D1qVlqBG6BBBhvRZnvX+
-----END RSA PUBLIC KEY-----`
	
	// Add trusted key - should succeed
	if err := sm.AddTrustedKey(keyID, publicKeyPEM); err != nil {
		t.Fatalf("AddTrustedKey failed: %v", err)
	}
	
	// Remove trusted key - should succeed
	if err := sm.RemoveTrustedKey(keyID); err != nil {
		t.Fatalf("RemoveTrustedKey failed: %v", err)
	}
	
	// Remove again should fail (key no longer exists)
	if err := sm.RemoveTrustedKey(keyID); err == nil {
		t.Error("RemoveTrustedKey should fail when key doesn't exist")
	}
}

// TestIsPluginTrusted tests plugin trust status
func TestIsPluginTrusted(t *testing.T) {
	sm := NewSecurityManager()
	
	// Create and sign plugin
	tmpDir := t.TempDir()
	testFile := filepath.Join(tmpDir, "test_plugin.go")
	testCode := []byte("package main\n\nfunc main() {}\n")
	if err := os.WriteFile(testFile, testCode, 0644); err != nil {
		t.Fatalf("Failed to create test file: %v", err)
	}
	
	pluginID := "test_plugin_005"
	if err := sm.SignPlugin(pluginID, testFile, "TestSigner"); err != nil {
		t.Fatalf("SignPlugin failed: %v", err)
	}
	
	// Initially should not be trusted (no trusted keys)
	if sm.IsPluginTrusted(pluginID) {
		t.Error("Plugin should not be trusted initially")
	}
	
	// Get the signing key
	sig, _ := sm.GetSignature(pluginID)
	
	// Add the signing key as trusted
	sm.trustedKeys[sig.Certificate] = &TrustedKey{
		KeyID:     sig.Certificate,
		AddedAt:   time.Now(),
		AddedBy:   "TestAdmin",
		IsRevoked: false,
	}
	
	// Now plugin should be trusted
	if !sm.IsPluginTrusted(pluginID) {
		t.Error("Plugin should be trusted after adding key")
	}
}

// TestGetSignatures tests retrieving all signatures
func TestGetSignatures(t *testing.T) {
	sm := NewSecurityManager()
	
	// Create temporary directory
	tmpDir := t.TempDir()
	
	// Sign multiple plugins
	for i := 1; i <= 3; i++ {
		testFile := filepath.Join(tmpDir, "test_plugin.go")
		testCode := []byte("package main\n\nfunc main() {}\n")
		if err := os.WriteFile(testFile, testCode, 0644); err != nil {
			t.Fatalf("Failed to create test file: %v", err)
		}
		
		pluginID := "test_plugin_" + string(rune('0'+i))
		if err := sm.SignPlugin(pluginID, testFile, "TestSigner"); err != nil {
			t.Fatalf("SignPlugin failed: %v", err)
		}
	}
	
	// Get all signatures
	signatures := sm.GetSignatures()
	if len(signatures) != 3 {
		t.Errorf("Expected 3 signatures, got %d", len(signatures))
	}
}

// TestGetSecurityStats tests security statistics
func TestGetSecurityStats(t *testing.T) {
	sm := NewSecurityManager()
	
	// Create and sign plugins
	tmpDir := t.TempDir()
	testFile := filepath.Join(tmpDir, "test_plugin.go")
	testCode := []byte("package main\n\nfunc main() {}\n")
	if err := os.WriteFile(testFile, testCode, 0644); err != nil {
		t.Fatalf("Failed to create test file: %v", err)
	}
	
	// Sign two plugins
	sm.SignPlugin("plugin1", testFile, "TestSigner")
	sm.SignPlugin("plugin2", testFile, "TestSigner")
	
	// Revoke one
	sm.RevokeSignature("plugin1", "Test revocation")
	
	// Get stats
	stats := sm.GetSecurityStats()
	
	totalSigs, ok := stats["total_signatures"].(int)
	if !ok || totalSigs != 2 {
		t.Errorf("Expected total_signatures=2, got %v", stats["total_signatures"])
	}
	
	revokedSigs, ok := stats["revoked_signatures"].(int)
	if !ok || revokedSigs != 1 {
		t.Errorf("Expected revoked_signatures=1, got %v", stats["revoked_signatures"])
	}
}

// TestSignatureExpiry tests signature expiration
func TestSignatureExpiry(t *testing.T) {
	sm := NewSecurityManager()
	
	// Create test plugin
	tmpDir := t.TempDir()
	testFile := filepath.Join(tmpDir, "test_plugin.go")
	testCode := []byte("package main\n\nfunc main() {}\n")
	if err := os.WriteFile(testFile, testCode, 0644); err != nil {
		t.Fatalf("Failed to create test file: %v", err)
	}
	
	pluginID := "test_plugin_006"
	if err := sm.SignPlugin(pluginID, testFile, "TestSigner"); err != nil {
		t.Fatalf("SignPlugin failed: %v", err)
	}
	
	// Manually expire the signature
	sig, _ := sm.GetSignature(pluginID)
	sig.ExpiresAt = time.Now().Add(-1 * time.Hour) // 1 hour ago
	sm.signatures[pluginID] = sig
	
	// Verification should fail for expired signature
	verified, err := sm.VerifyPlugin(pluginID, testFile)
	if verified || err == nil {
		t.Error("VerifyPlugin should fail for expired signature")
	}
}

// TestConcurrentSigning tests concurrent signing operations
func TestConcurrentSigning(t *testing.T) {
	sm := NewSecurityManager()
	
	// Create test file
	tmpDir := t.TempDir()
	testFile := filepath.Join(tmpDir, "test_plugin.go")
	testCode := []byte("package main\n\nfunc main() {}\n")
	if err := os.WriteFile(testFile, testCode, 0644); err != nil {
		t.Fatalf("Failed to create test file: %v", err)
	}
	
	// Sign 10 plugins concurrently
	var wg sync.WaitGroup
	for i := 0; i < 10; i++ {
		wg.Add(1)
		go func(id int) {
			defer wg.Done()
			pluginID := "concurrent_plugin_" + string(rune('0'+id))
			if err := sm.SignPlugin(pluginID, testFile, "TestSigner"); err != nil {
				t.Errorf("Concurrent SignPlugin failed for %s: %v", pluginID, err)
			}
		}(i)
	}
	wg.Wait()
	
	// Verify all signatures created
	signatures := sm.GetSignatures()
	if len(signatures) != 10 {
		t.Errorf("Expected 10 concurrent signatures, got %d", len(signatures))
	}
}

// TestConcurrentVerification tests concurrent verification operations
func TestConcurrentVerification(t *testing.T) {
	sm := NewSecurityManager()
	
	// Create and sign test plugin
	tmpDir := t.TempDir()
	testFile := filepath.Join(tmpDir, "test_plugin.go")
	testCode := []byte("package main\n\nfunc main() {}\n")
	if err := os.WriteFile(testFile, testCode, 0644); err != nil {
		t.Fatalf("Failed to create test file: %v", err)
	}
	
	pluginID := "concurrent_verify"
	if err := sm.SignPlugin(pluginID, testFile, "TestSigner"); err != nil {
		t.Fatalf("SignPlugin failed: %v", err)
	}
	
	// Verify 10 times concurrently
	var wg sync.WaitGroup
	errors := make(chan error, 10)
	for i := 0; i < 10; i++ {
		wg.Add(1)
		go func() {
			defer wg.Done()
			if verified, err := sm.VerifyPlugin(pluginID, testFile); !verified || err != nil {
				errors <- err
			}
		}()
	}
	wg.Wait()
	close(errors)
	
	// Check for any errors
	for err := range errors {
		t.Errorf("Concurrent verification failed: %v", err)
	}
}

// TestAuditLog tests security audit logging
func TestAuditLog(t *testing.T) {
	sm := NewSecurityManager()
	
	// Create and sign plugin
	tmpDir := t.TempDir()
	testFile := filepath.Join(tmpDir, "test_plugin.go")
	testCode := []byte("package main\n\nfunc main() {}\n")
	if err := os.WriteFile(testFile, testCode, 0644); err != nil {
		t.Fatalf("Failed to create test file: %v", err)
	}
	
	pluginID := "audit_test_plugin"
	sm.SignPlugin(pluginID, testFile, "TestSigner")
	sm.VerifyPlugin(pluginID, testFile)
	sm.RevokeSignature(pluginID, "Test audit")
	
	// Get audit log
	auditLog := sm.GetAuditLog()
	if len(auditLog) < 3 {
		t.Errorf("Expected at least 3 audit entries, got %d", len(auditLog))
	}
	
	// Verify audit entries contain expected actions
	actions := make(map[string]bool)
	for _, entry := range auditLog {
		actions[entry.Action] = true
	}
	
	expectedActions := []string{"sign", "verify", "revoke"}
	for _, action := range expectedActions {
		if !actions[action] {
			t.Errorf("Expected audit log to contain action '%s'", action)
		}
	}
}
